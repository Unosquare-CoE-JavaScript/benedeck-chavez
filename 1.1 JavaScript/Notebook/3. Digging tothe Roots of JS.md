# Digging tothe Roots of JS

1. [Iteration](#iteration)
2. [Closure](#closure)
3. [this Keyword](#thisKeyword)
4. [Prototypes](#prototypes)

## <a id="iteration"></a> Iteration

ES6 standardized a specific protocol for the iterator pattern directly in the language. The protocol defines a **next()** method whose return is an object called an **iterator result;** the object has value and done properties, where done is a boolean that is false until the iteration over the underlying data source is complete.

**Consuming Iterators**

ES6 also included several mechanisms (syntax and APIs) for standardized consumption of these iterators.

_the for...of loop_

```
// given an iterator of some data source:
var it = /* .. */;
// loop over its results one at a time
for(let val of it)
{
    console.log(`Iterator value:${val}`);
}
// Iterator value: ..
// Iterator value: ..
// ..
```

_the ... operator_

This operator actually has two symmetrical forms: spread and rest

```
// An array spread:
// spread an iterator into an array,
// with each iterated value occupying
// an array element position.
var vals = [ ...it ];

//A function call spread:
// spread an iterator into a function,
// call with each iterated value
// occupying an argument position.
doSomethingUseful( ...it );
```

The iterator-spread form of **...** follows the iterator-consumption protocol (the same as the **for..of** loop) to retrieve all available values from an iterator and place (aka, spread)them into the receiving context (array, argument list).

**Iterables**

The iterator-consumption protocol is technically defined for consuming iterables; an iterable is a value that can be iterated over.
ES6 defined the basic data structure/collection types in JS as iterables. This includes strings, arrays, maps, sets, and others.

**Array**

```
// an array is an iterable
var arr=[10,20,30];

for(let val of arr) {
    console.log(`Array value:${val}`);
}
// Array value: 10
// Array value: 20
// Array value: 30

//Since arrays are iterables,
//we can shallow-copy an array using iterator
//consumption via the ... spread operator
var arrCopy=[ ...arr ];

//We can also iterate the characters in a string one at a time:
var greeting="Hello world!";
var chars=[ ...greeting ];
chars;
// [ "H", "e", "l", "l", "o", " ",
//   "w", "o", "r", "l", "d", "!" ]
```

**Map**

A Map data structure uses objects as keys, associating a value (of any type) with that object.
An entry is a tuple (2-element array) including both a key and a value.

```
// given two DOM elements, `btn1` and `btn2`
var buttonNames = newMap();
buttonNames.set(btn1,"Button 1");
buttonNames.set(btn2,"Button 2");

for(let [btn,btnName] of buttonNames) {
    btn.addEventListener("click",function onClick(){
        console.log(`Clicked ${ btnName }`);
    });
}
```

For the most part, all built-in iterables in JS have three iterator forms available: keys-only(keys()), values-only(values()), and entries (entries()).

```
for(let btnName of buttonNames.values()) {
    console.log(btnName);
}
// Button 1
// Button 2

var arr=[10,20,30];
for( let [idx,val] of arr.entries()) {
    console.log(`[${idx}]:${val}`);
}
// [0]: 10
// [1]: 20
// [2]: 30
```

## <a id="closure"></a> Closure

Closure is when a function remembers and continues to access variables from out side its scope, even when the function is executed in a different scope.

## <a id="thisKeyword"></a> this Keyword

## <a id="prototypes"></a> Prototypes
